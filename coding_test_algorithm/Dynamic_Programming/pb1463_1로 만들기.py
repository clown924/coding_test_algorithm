# 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
# 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
# 2. X가 2로 나누어 떨어지면, 2로 나눈다.
# 3. 1을 뺀다.

# 정수 N이 주어졌을 때,
# 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다.
# 연산을 사용하는 횟수의 최솟값을 출력하시오.
# ex ) 10 -> 9 -> 3 -> 1  => O
# ex ) 10 -> 5 -> 4 -> 2 -> 1 => X

# 문제 해결 방법
# 동적 계획법으로 해결하기 위해, 연산횟수를 저장한 리스트를 만든다.
# N이 3으로 나누어 떨어지면 d[N//3] + 1
# N이 2로 나누어 떨어지면 d[N//2] + 1
# 1을 뺄 때는 d[N-1] + 1
# 각각 +1을 하는 이유는 각각 연산을 하기 때문이다.
# 3으로 나누는 것이 더 줄일 수 있는지,
# 1을 빼는 것이 더 줄일 수 있는지 비교하기 위해
# min(d[i],d[i//3]+1) 을 비교하는 것이다.

import sys
count = 0
N = int(sys.stdin.readline())

d = [0 for _ in range(N+1)]
# d는 각 index에 대응된 숫자의 연산 횟수를 저장한 리스트이다.
for i in range(2, N+1):
    d[i] = d[i-1] + 1
    # 1을 빼는 것 +1을 하는 것은 빼는 연산을 했으므로

    if i % 3 == 0:   # 3으로 나누어지면
        d[i] = min(d[i],d[i//3]+1)
    # 마찬가지로 3으로 나누는 연산을 했기 때문에 +1
    if i % 2 == 0:
        d[i] = min(d[i],d[i//2]+1)
    # 마찬가지로 2로 나누는 연산을 했기 때문에 +1

print(d[N])
